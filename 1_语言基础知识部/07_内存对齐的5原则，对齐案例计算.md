# 问题：内存对齐的5原则，对齐案例计算？

**5原则**：一般是三个原则，但是关于特殊成员还有额外的两条原则。
1. `数据成员对齐规则`：结构/类(struct/class)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员(只要该成员有子成员，比如数组、结构体等)大小的整数倍开始。比如int要从4的整数倍地址开始存储。
2. `结构体作为成员`：如果一个结构A嵌套了其他结构体B，要从B最大元素整数倍地址开始存值(struct a如果嵌套struct b，而b内部有int/double/char，则元素b应该从8的整数倍开始存储)
3. `收尾工作`：结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的整数倍。不足的要补齐。
4. `函数和static`：函数不占用sizeof的内容，static变量属于类的成员，而不是特定对象的成员。
5. `带虚函数的类`：有一个虚函数表指针vptr，属于对象首部，必须要和最大元素的大小一致。


```c++
// 案例1：简单场景
struct xx {
    long long _x1; // 8字节 [01234567]占用8字节
    char _x2; // 1字节 [8***]占用4字节
    int _x3; // 4字节 [12 13 14 15]占用4字节
    char _x4[2]; // 2字节 [16 17 ******]占用2+6=8字节
}; // 总占用24个字节

// 案例2：嵌套结构体
struct a {
    long long _x5; // 8字节 [01234567]占用8字节
    char _x6; // 1字节 [8*******]占用8字节
    xx a; // 24字节 要求从8倍数开始存储（注意这里虽然大小是24但是对齐是按照最大元素8算） [16 ... 39]占用24字节
    char _x4[2]; // 2字节 尾部填充到最大元素8的倍数 [40 41 ******]占用8字节
}; // 总占用48个字节

// 案例3：静态成员和函数
struct b{
    static int c; // 这个成员是存储在类上的，不是对象的
    void func(){} // 这个成员函数也是在类上，不在对象上
    virtual void funcv(){} // x86中按道理vptr是4字节，但是此指针需要和最大的成员对齐尺寸进行对齐。（下面的案例进行了测试，即使有一个很大的结构体成员，也是只取结构体成员的对齐尺寸大小）
};
```

```c++
struct A {
	int a; // 4 => 8
	long long b; // 8 => 8
	int c; // 4 => 8
}; // 总共24字节

struct B {
	virtual void func() {}; // x86本来应该是4字节，但是按照最大对齐算，所以占8字节
	int a; // 4 => 8
	long long b; // 8 => 8
	A a1; // 24
	int c; // 4 => 8
}; // 总共57字节
```

